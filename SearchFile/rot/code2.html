<!DOCTYPE html>
<html lang=zh>

    <head>
        <meta charset="utf-8">
        
            <title>
                
                    Code2 | 
                            ysun &amp; Blog
            </title>
            
                
                    <meta name="keywords" content="Code2" />
                    
                        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
                        <meta name="description" content="&#x2F;&#x2F; &lt;!--GAMFC--&gt;version base on commit 4bc1p4y2a9f5d698reyse7702hp4k0p7mzcfqa92c9ef5rpq6g7u293yqs3vvdkf5rpq6g7u293yqs3vvdk, time is 2023-06-22 15:20:05 UTC&lt;!--GAMFC-END--&gt;. &#x2F;&#x2F; @ts-ignore im">
<meta property="og:type" content="website">
<meta property="og:title" content="Code2">
<meta property="og:url" content="https://ysunyang979-sys.github.io/SearchFile/rot/code2.html">
<meta property="og:site_name" content="ysun &amp; Blog">
<meta property="og:description" content="&#x2F;&#x2F; &lt;!--GAMFC--&gt;version base on commit 4bc1p4y2a9f5d698reyse7702hp4k0p7mzcfqa92c9ef5rpq6g7u293yqs3vvdkf5rpq6g7u293yqs3vvdk, time is 2023-06-22 15:20:05 UTC&lt;!--GAMFC-END--&gt;. &#x2F;&#x2F; @ts-ignore im">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-12-28T15:15:00.000Z">
<meta property="article:modified_time" content="2026-02-11T11:58:15.371Z">
<meta property="article:author" content="ysun">
<meta name="twitter:card" content="summary">
                            

                                
                                    <link rel="alternate" href="/atom.xml"
                                        title="ysun &amp; Blog" type="application/atom+xml" />
                                    

                                        
                                            <link rel="icon" href="/favicon.png" />
                                            

                                                
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

                                                    
<link rel="stylesheet" href="/libs/open-sans/styles.css">

                                                        
<link rel="stylesheet" href="/libs/source-code-pro/styles.css">

                                                            <link rel="stylesheet"
                                                                href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css">
                                                            <link rel="stylesheet"
                                                                href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css">
                                                            <link rel="stylesheet" href="/css/pdf-tools.css">
                                                            <link rel="stylesheet" href="/css/custom-style.css">

                                                            
<link rel="stylesheet" href="/css/style.css">

                                                                
<script src="/libs/jquery/2.1.3/jquery.min.js"></script>

                                                                    
<script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script>

                                                                        
    
        
<link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">

    
    
        
<link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">

    
    
    
    


                                                                            
                                                                                <script async
                                                                                    src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
                                                                                
    <meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                
                <span class="site-title">ysun &amp; Blog</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/">首页</a>
                
                    <a class="main-nav-link" href="/archives">归档</a>
                
                    <a class="main-nav-link" href="/about">关于</a>
                
                    <a class="main-nav-link" href="/SearchFile">Ysun</a>
                
                    <a class="main-nav-link" href="/daynote">Daynote</a>
                
            </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>


</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/">首页</a></td>
                
                    <td><a class="main-nav-link" href="/archives">归档</a></td>
                
                    <td><a class="main-nav-link" href="/about">关于</a></td>
                
                    <td><a class="main-nav-link" href="/SearchFile">Ysun</a></td>
                
                    <td><a class="main-nav-link" href="/daynote">Daynote</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
            
                <aside id="sidebar">
    
        
    <div class="widget-wrap" id='categories'>
        <h3 class="widget-title">
            <span id="tab-category" class="widget-tab active">分类</span>
            <span id="tab-links" class="widget-tab">
                <i class="fa fa-link"></i>
            </span>
            <a id='allExpand' href="#" style="float: right;">
                <i class="fa fa-angle-double-down fa-2x"></i>
            </a>
        </h3>
        
        <div id="content-category">
            
            
             <ul class="unstyled" id="tree" > 
                        <li class="directory">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                unity
                            </a>
                             <ul class="unstyled" id="tree" > 
                        <li class="directory">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                四部曲
                            </a>
                             <ul class="unstyled" id="tree" > 
                        <li class="directory">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                入门
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/2024/09/29/%E5%9B%9B%E9%83%A8%E6%9B%B2/%E5%85%A5%E9%97%A8/001unity%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></li>  <li class="file"><a href="/2024/09/29/%E5%9B%9B%E9%83%A8%E6%9B%B2/%E5%85%A5%E9%97%A8/0000/">条件运算</a></li>  <li class="file"><a href="/2024/09/29/%E5%9B%9B%E9%83%A8%E6%9B%B2/%E5%85%A5%E9%97%A8/0001/">异常捕获</a></li>  <li class="file"><a href="/2024/10/31/%E5%9B%9B%E9%83%A8%E6%9B%B2/%E5%85%A5%E9%97%A8/002%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6/">三目运算符</a></li>  <li class="file"><a href="/2024/10/31/%E5%9B%9B%E9%83%A8%E6%9B%B2/%E5%85%A5%E9%97%A8/000/">if</a></li>  <li class="file"><a href="/2024/10/31/%E5%9B%9B%E9%83%A8%E6%9B%B2/%E5%85%A5%E9%97%A8/003Switch/">Switch</a></li>  <li class="file"><a href="/2024/10/31/%E5%9B%9B%E9%83%A8%E6%9B%B2/%E5%85%A5%E9%97%A8/004While/">While</a></li>  <li class="file"><a href="/2024/10/31/%E5%9B%9B%E9%83%A8%E6%9B%B2/%E5%85%A5%E9%97%A8/005Do%20While/">Do While</a></li>  <li class="file"><a href="/2024/10/31/%E5%9B%9B%E9%83%A8%E6%9B%B2/%E5%85%A5%E9%97%A8/006For/">For</a></li>  <li class="file"><a href="/2024/10/31/%E5%9B%9B%E9%83%A8%E6%9B%B2/%E5%85%A5%E9%97%A8/007%E6%8E%A7%E5%88%B6%E5%8F%B0/">控制台</a></li>  <li class="file"><a href="/2024/10/31/%E5%9B%9B%E9%83%A8%E6%9B%B2/%E5%85%A5%E9%97%A8/008%E9%9A%8F%E6%9C%BA%E6%95%B0/">随机数</a></li>  <li class="file"><a href="/2024/11/01/%E5%9B%9B%E9%83%A8%E6%9B%B2/%E5%85%A5%E9%97%A8/009%E9%A1%B9%E7%9B%AE%E8%B0%83%E8%AF%95/">项目调试</a></li>  <li class="file"><a href="/2024/11/01/%E5%9B%9B%E9%83%A8%E6%9B%B2/%E5%85%A5%E9%97%A8/010/">需求分析</a></li>  </ul> 
                        </li> 
                         </ul> 
                        </li> 
                        
                        <li class="directory">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                效率/技巧
                            </a>
                             <ul class="unstyled" id="tree" > 
                        <li class="directory">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                3D建模
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/2024/05/21/unity3d-model/">unity3D模型处理</a></li>  </ul> 
                        </li> 
                        
                        <li class="directory">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                TMP设置
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/2024/05/21/unity%E5%AD%97%E4%BD%93%E8%AE%BE%E7%BD%AE/">unity字体TMP设置</a></li>  </ul> 
                        </li> 
                        
                        <li class="directory">
                            <a href="#" data-role="directory">
                                <i class="fa fa-folder"></i>
                                &nbsp;
                                插件
                            </a>
                             <ul class="unstyled" id="tree" >  <li class="file"><a href="/2024/05/21/unityplug/">unity插件</a></li>  </ul> 
                        </li> 
                         </ul> 
                        </li> 
                         </ul> 
                        </li> 
                         </ul> 
        </div>

        <div id="content-links" style="display: none;">
            <ul class="unstyled">
                
                    
                        <li style="padding: 5px 0;">
                            <a href="https://ray2v.ysunyang.dpdns.org/admin" target="_blank">
                                <i class="fa fa-link"></i>&nbsp;优选IP
                            </a>
                        </li>
                    
                        <li style="padding: 5px 0;">
                            <a href="https://dashboard.katabump.com/dashboard" target="_blank">
                                <i class="fa fa-link"></i>&nbsp;科学上网VPS（Discord登录）
                            </a>
                        </li>
                    
                        <li style="padding: 5px 0;">
                            <a href="https://mail.proton.me/u/0/inbox" target="_blank">
                                <i class="fa fa-link"></i>&nbsp;Proton邮箱
                            </a>
                        </li>
                    
                        <li style="padding: 5px 0;">
                            <a href="https://www.youtube.com" target="_blank">
                                <i class="fa fa-link"></i>&nbsp;油管
                            </a>
                        </li>
                    
                        <li style="padding: 5px 0;">
                            <a href="https://www.spaceship.com/zh/auth/?returnUrl=%2Fapplication%2Fdomain-list-application%2F" target="_blank">
                                <i class="fa fa-link"></i>&nbsp;域名
                            </a>
                        </li>
                    
                        <li style="padding: 5px 0;">
                            <a href="https://my.dnshe.com/index.php?m=domain_hub" target="_blank">
                                <i class="fa fa-link"></i>&nbsp;免费域名dnshe
                            </a>
                        </li>
                    
                        <li style="padding: 5px 0;">
                            <a href="https://picx.xpoet.cn/#/?jump=0" target="_blank">
                                <i class="fa fa-link"></i>&nbsp;图床（GitHub登录）
                            </a>
                        </li>
                    
                        <li style="padding: 5px 0;">
                            <a href="https://temp-mail-worker.3589665628.workers.dev/" target="_blank">
                                <i class="fa fa-link"></i>&nbsp;无限马甲邮箱
                            </a>
                        </li>
                    
                        <li style="padding: 5px 0;">
                            <a href="https://todo-snowy-rho.vercel.app/index-zh.html" target="_blank">
                                <i class="fa fa-link"></i>&nbsp;ToDOList
                            </a>
                        </li>
                    
                        <li style="padding: 5px 0;">
                            <a href="https://demo2apk.lasuo.ai/" target="_blank">
                                <i class="fa fa-link"></i>&nbsp;APK打包
                            </a>
                        </li>
                    
                        <li style="padding: 5px 0;">
                            <a href="https://www.scribd.com/home" target="_blank">
                                <i class="fa fa-link"></i>&nbsp;Scribd书籍下载
                            </a>
                        </li>
                    
                        <li style="padding: 5px 0;">
                            <a href="https://ysite74.vercel.app/" target="_blank">
                                <i class="fa fa-link"></i>&nbsp;聚合网站
                            </a>
                        </li>
                    
                        <li style="padding: 5px 0;">
                            <a href="https://uplugin.vercel.app/" target="_blank">
                                <i class="fa fa-link"></i>&nbsp;Unity插件
                            </a>
                        </li>
                    
                
            </ul>
        </div>

    </div>
    <script>
        $(document).ready(function() {
            var iconFolderOpenClass  = 'fa-folder-open';
            var iconFolderCloseClass = 'fa-folder';
            var iconAllExpandClass = 'fa-angle-double-down';
            var iconAllPackClass = 'fa-angle-double-up';
            
            // Tab switching logic
            $('#tab-category').click(function() {
                $('#content-category').show();
                $('#content-links').hide();
                $('#allExpand').show(); // Show expand button for category
                $(this).addClass('active');
                $('#tab-links').removeClass('active');
            });

            $('#tab-links').click(function() {
                $('#content-category').hide();
                $('#content-links').show();
                $('#allExpand').hide(); // Hide expand button for links
                $(this).addClass('active');
                $('#tab-category').removeClass('active');
            });

            // Handle directory-tree expansion:
            // 左键单独展开目录
            $(document).on('click', '#categories a[data-role="directory"]', function (event) {
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var subtree = $(this).siblings('ul');
                icon.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if (expanded) {
                    if (typeof subtree != 'undefined') {
                        subtree.slideUp({ duration: 100 });
                    }
                    icon.addClass(iconFolderCloseClass);
                } else {
                    if (typeof subtree != 'undefined') {
                        subtree.slideDown({ duration: 100 });
                    }
                    icon.addClass(iconFolderOpenClass);
                }
            });
            // 右键展开下属所有目录
            $('#categories a[data-role="directory"]').bind("contextmenu", function(event){
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var listNode = $(this).siblings('ul');
                var subtrees = $.merge(listNode.find('li ul'), listNode);
                var icons = $.merge(listNode.find('.fa'), icon);
                icons.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if(expanded) {
                    subtrees.slideUp({ duration: 100 });
                    icons.addClass(iconFolderCloseClass);
                } else {
                    subtrees.slideDown({ duration: 100 });
                    icons.addClass(iconFolderOpenClass);
                }
            })
            // 展开关闭所有目录按钮
            $(document).on('click', '#allExpand', function (event) {
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconAllExpandClass);
                icon.removeClass(iconAllExpandClass).removeClass(iconAllPackClass);
                if(expanded) {
                    $('#sidebar .fa.fa-folder').removeClass('fa-folder').addClass('fa-folder-open')
                    $('#categories li ul').slideDown({ duration: 100 });
                    icon.addClass(iconAllPackClass);
                } else {
                    $('#sidebar .fa.fa-folder-open').removeClass('fa-folder-open').addClass('fa-folder')
                    $('#categories li ul').slideUp({ duration: 100 });
                    icon.addClass(iconAllExpandClass);
                }
            });  
        });
    </script>

    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
            <section id="main"><article id="page-" class="article article-type-page" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                
    
        <h1 class="article-title" itemprop="name">
            Code2
        </h1>
    

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <pre><code class="c">// &lt;!--GAMFC--&gt;version base on commit 4bc1p4y2a9f5d698reyse7702hp4k0p7mzcfqa92c9ef5rpq6g7u293yqs3vvdkf5rpq6g7u293yqs3vvdk, time is 2023-06-22 15:20:05 UTC&lt;!--GAMFC-END--&gt;.
// @ts-ignore
import &#123; connect &#125; from &#39;cloudflare:sockets&#39;;

// How to generate your own UUID:
// [Windows] Press &quot;Win + R&quot;, input cmd and run:  Powershell -NoExit -Command &quot;[guid]::NewGuid()&quot;
let userID = &#39;90cd4a77-141a-43c9-991b-08263cfe9c10&#39;;

let proxyIP = &#39;&#39;;// 小白勿动，该地址并不影响你的网速，这是给CF代理使用的。&#39;cdn.xn--b6gac.eu.org, cdn-all.xn--b6gac.eu.org, workers.cloudflare.cyou&#39;

let sub = &#39;&#39;;// 留空则使用内置订阅
let subconverter = &#39;url.v1.mk&#39;;// clash订阅转换后端，目前使用肥羊的订阅转换功能。自带虚假uuid和host订阅。
let subconfig = &quot;https://raw.githubusercontent.com/cmliu/ACL4SSR/main/Clash/config/ACL4SSR_Online_Full_MultiMode.ini&quot;; //订阅配置文件

// The user name and password do not contain special characters
// Setting the address will ignore proxyIP
// Example:  user:pass@host:port  or  host:port
let socks5Address = &#39;&#39;;

if (!isValidUUID(userID)) &#123;
    throw new Error(&#39;uuid is not valid&#39;);
&#125;

let parsedSocks5Address = &#123;&#125;; 
let enableSocks = false;

// 虚假uuid和hostname，用于发送给配置生成服务
let fakeUserID ;
let fakeHostName ;
let noTLS = &#39;false&#39;; 
const expire = 4102329600;//2099-12-31
let proxyIPs;
let addresses = [];
let addressesapi = [];
let addressesnotls = [];
let addressesnotlsapi = [];
let addressescsv = [];
let DLS = 8;
let FileName = &#39;edgetunnel&#39;;
let BotToken =&#39;&#39;;
let ChatID =&#39;&#39;; 
let proxyhosts = [];//本地代理域名池
let proxyhostsURL = &#39;https://raw.githubusercontent.com/cmliu/CFcdnVmess2sub/main/proxyhosts&#39;;//在线代理域名池URL
let RproxyIP = &#39;false&#39;;
export default &#123;
    /**
     * @param &#123;import(&quot;@cloudflare/workers-types&quot;).Request&#125; request
     * @param &#123;&#123;UUID: string, PROXYIP: string&#125;&#125; env
     * @param &#123;import(&quot;@cloudflare/workers-types&quot;).ExecutionContext&#125; ctx
     * @returns &#123;Promise&lt;Response&gt;&#125;
     */
    async fetch(request, env, ctx) &#123;
        try &#123;
            const UA = request.headers.get(&#39;User-Agent&#39;) || &#39;null&#39;;
            const userAgent = UA.toLowerCase();
            userID = (env.UUID || userID).toLowerCase();

            const currentDate = new Date();
            currentDate.setHours(0, 0, 0, 0); 
            const timestamp = Math.ceil(currentDate.getTime() / 1000);
            const fakeUserIDMD5 = await MD5MD5(`$&#123;userID&#125;$&#123;timestamp&#125;`);
            fakeUserID = fakeUserIDMD5.slice(0, 8) + &quot;-&quot; + fakeUserIDMD5.slice(8, 12) + &quot;-&quot; + fakeUserIDMD5.slice(12, 16) + &quot;-&quot; + fakeUserIDMD5.slice(16, 20) + &quot;-&quot; + fakeUserIDMD5.slice(20);
            fakeHostName = fakeUserIDMD5.slice(6, 9) + &quot;.&quot; + fakeUserIDMD5.slice(13, 19);
            //console.log(`$&#123;fakeUserID&#125;\n$&#123;fakeHostName&#125;`); // 打印fakeID

            proxyIP = env.PROXYIP || proxyIP;
            proxyIPs = await ADD(proxyIP);
            proxyIP = proxyIPs[Math.floor(Math.random() * proxyIPs.length)];
            //console.log(proxyIP);
            socks5Address = env.SOCKS5 || socks5Address;
            sub = env.SUB || sub;
            subconverter = env.SUBAPI || subconverter;
            subconfig = env.SUBCONFIG || subconfig;
            if (socks5Address) &#123;
                try &#123;
                    parsedSocks5Address = socks5AddressParser(socks5Address);
                    RproxyIP = env.RPROXYIP || &#39;false&#39;;
                    enableSocks = true;
                &#125; catch (err) &#123;
                      /** @type &#123;Error&#125; */ 
                    let e = err;
                    console.log(e.toString());
                    RproxyIP = env.RPROXYIP || !proxyIP ? &#39;true&#39; : &#39;false&#39;;
                    enableSocks = false;
                &#125;
            &#125; else &#123;
                RproxyIP = env.RPROXYIP || !proxyIP ? &#39;true&#39; : &#39;false&#39;;
            &#125;
            if (env.ADD) addresses = await ADD(env.ADD);
            if (env.ADDAPI) addressesapi = await ADD(env.ADDAPI);
            if (env.ADDNOTLS) addressesnotls = await ADD(env.ADDNOTLS);
            if (env.ADDNOTLSAPI) addressesnotlsapi = await ADD(env.ADDNOTLSAPI);
            if (env.ADDCSV) addressescsv = await ADD(env.ADDCSV);
            DLS = env.DLS || DLS;
            BotToken = env.TGTOKEN || BotToken;
            ChatID = env.TGID || ChatID; 
            const upgradeHeader = request.headers.get(&#39;Upgrade&#39;);
            const url = new URL(request.url);
            if (url.searchParams.has(&#39;notls&#39;)) noTLS = &#39;true&#39;;
            if (!upgradeHeader || upgradeHeader !== &#39;websocket&#39;) &#123;
                // const url = new URL(request.url);
                switch (url.pathname.toLowerCase()) &#123;
                case &#39;/&#39;:
                    const envKey = env.URL302 ? &#39;URL302&#39; : (env.URL ? &#39;URL&#39; : null);
                    if (envKey) &#123;
                        const URLs = await ADD(env[envKey]);
                        const URL = URLs[Math.floor(Math.random() * URLs.length)];
                        return envKey === &#39;URL302&#39; ? Response.redirect(URL, 302) : fetch(new Request(URL, request));
                    &#125;
                    return new Response(JSON.stringify(request.cf, null, 4), &#123; status: 200 &#125;);
                case `/$&#123;fakeUserID&#125;`:
                    const fakeConfig = await getVLESSConfig(userID, request.headers.get(&#39;Host&#39;), sub, &#39;CF-Workers-SUB&#39;, RproxyIP, url);
                    return new Response(`$&#123;fakeConfig&#125;`, &#123; status: 200 &#125;);
                case `/$&#123;userID&#125;`: &#123;
                    await sendMessage(`#获取订阅 $&#123;FileName&#125;`, request.headers.get(&#39;CF-Connecting-IP&#39;), `UA: $&#123;UA&#125;&lt;/tg-spoiler&gt;\n域名: $&#123;url.hostname&#125;\n&lt;tg-spoiler&gt;入口: $&#123;url.pathname + url.search&#125;&lt;/tg-spoiler&gt;`);
                    if ((!sub || sub == &#39;&#39;) &amp;&amp; (addresses.length + addressesapi.length + addressesnotls.length + addressesnotlsapi.length + addressescsv.length) == 0) sub = &#39;vless-4ca.pages.dev&#39;;
                    const vlessConfig = await getVLESSConfig(userID, request.headers.get(&#39;Host&#39;), sub, UA, RproxyIP, url);
                    const now = Date.now();
                    //const timestamp = Math.floor(now / 1000);
                    const today = new Date(now);
                    today.setHours(0, 0, 0, 0);
                    const UD = Math.floor(((now - today.getTime())/86400000) * 24 * 1099511627776 / 2);
                    let pagesSum = UD;
                    let workersSum = UD;
                    let total = 24 * 1099511627776 ;
                    if (env.CFEMAIL &amp;&amp; env.CFKEY)&#123;
                        const email = env.CFEMAIL;
                        const key = env.CFKEY;
                        const accountIndex = env.CFID || 0;
                        const accountId = await getAccountId(email, key);
                        if (accountId)&#123;
                            const now = new Date()
                            now.setUTCHours(0, 0, 0, 0)
                            const startDate = now.toISOString()
                            const endDate = new Date().toISOString();
                            const Sum = await getSum(accountId, accountIndex, email, key, startDate, endDate);
                            pagesSum = Sum[0];
                            workersSum = Sum[1];
                            total = 102400 ;
                        &#125;
                    &#125;
                    //console.log(`pagesSum: $&#123;pagesSum&#125;\nworkersSum: $&#123;workersSum&#125;\ntotal: $&#123;total&#125;`);
                    if (userAgent &amp;&amp; userAgent.includes(&#39;mozilla&#39;))&#123;
                        return new Response(`$&#123;vlessConfig&#125;`, &#123;
                            status: 200,
                            headers: &#123;
                                &quot;Content-Type&quot;: &quot;text/plain;charset=utf-8&quot;,
                                &quot;Profile-Update-Interval&quot;: &quot;6&quot;,
                                &quot;Subscription-Userinfo&quot;: `upload=$&#123;pagesSum&#125;; download=$&#123;workersSum&#125;; total=$&#123;total&#125;; expire=$&#123;expire&#125;`,
                            &#125;
                        &#125;);
                    &#125; else &#123;
                        return new Response(`$&#123;vlessConfig&#125;`, &#123;
                            status: 200,
                            headers: &#123;
                                &quot;Content-Disposition&quot;: `attachment; filename=$&#123;FileName&#125;; filename*=utf-8&#39;&#39;$&#123;encodeURIComponent(FileName)&#125;`,
                                &quot;Content-Type&quot;: &quot;text/plain;charset=utf-8&quot;,
                                &quot;Profile-Update-Interval&quot;: &quot;6&quot;,
                                &quot;Subscription-Userinfo&quot;: `upload=$&#123;pagesSum&#125;; download=$&#123;workersSum&#125;; total=$&#123;total&#125;; expire=$&#123;expire&#125;`,
                            &#125;
                        &#125;);
                    &#125;
                &#125;
                default:
                    return new Response(&#39;Not found&#39;, &#123; status: 404 &#125;);
                &#125;
            &#125; else &#123;
                proxyIP = url.searchParams.get(&#39;proxyip&#39;) || proxyIP;
                if (new RegExp(&#39;/proxyip=&#39;, &#39;i&#39;).test(url.pathname)) proxyIP = url.pathname.toLowerCase().split(&#39;/proxyip=&#39;)[1];
                else if (new RegExp(&#39;/proxyip.&#39;, &#39;i&#39;).test(url.pathname)) proxyIP = `proxyip.$&#123;url.pathname.toLowerCase().split(&quot;/proxyip.&quot;)[1]&#125;`;
                else if (!proxyIP || proxyIP == &#39;&#39;) proxyIP = &#39;proxyip.fxxk.dedyn.io&#39;;
                
                socks5Address = url.searchParams.get(&#39;socks5&#39;) || socks5Address;
                if (new RegExp(&#39;/socks5=&#39;, &#39;i&#39;).test(url.pathname)) socks5Address = url.pathname.split(&#39;5=&#39;)[1];
                else if (new RegExp(&#39;/socks://&#39;, &#39;i&#39;).test(url.pathname) || new RegExp(&#39;/socks5://&#39;, &#39;i&#39;).test(url.pathname)) &#123;
                    socks5Address = url.pathname.split(&#39;://&#39;)[1].split(&#39;#&#39;)[0];
                    if (socks5Address.includes(&#39;@&#39;))&#123;
                        let userPassword = socks5Address.split(&#39;@&#39;)[0];
                        const base64Regex = /^(?:[A-Z0-9+/]&#123;4&#125;)*(?:[A-Z0-9+/]&#123;2&#125;==|[A-Z0-9+/]&#123;3&#125;=)?$/i;
                        if (base64Regex.test(userPassword) &amp;&amp; !userPassword.includes(&#39;:&#39;)) userPassword = atob(userPassword);
                        socks5Address = `$&#123;userPassword&#125;@$&#123;socks5Address.split(&#39;@&#39;)[1]&#125;`;
                    &#125;
                &#125;
                if (socks5Address) &#123;
                    try &#123;
                        parsedSocks5Address = socks5AddressParser(socks5Address);
                        enableSocks = true;
                    &#125; catch (err) &#123;
                        /** @type &#123;Error&#125; */ 
                        let e = err;
                        console.log(e.toString());
                        enableSocks = false;
                    &#125;
                &#125; else &#123;
                    enableSocks = false;
                &#125;
                return await vlessOverWSHandler(request);
            &#125;
        &#125; catch (err) &#123;
            /** @type &#123;Error&#125; */ let e = err;
            return new Response(e.toString());
        &#125;
    &#125;,
&#125;;

/**
 * 
 * @param &#123;import(&quot;@cloudflare/workers-types&quot;).Request&#125; request
 */
async function vlessOverWSHandler(request) &#123;

    /** @type &#123;import(&quot;@cloudflare/workers-types&quot;).WebSocket[]&#125; */
    // @ts-ignore
    const webSocketPair = new WebSocketPair();
    const [client, webSocket] = Object.values(webSocketPair);

    webSocket.accept();

    let address = &#39;&#39;;
    let portWithRandomLog = &#39;&#39;;
    const log = (/** @type &#123;string&#125; */ info, /** @type &#123;string | undefined&#125; */ event) =&gt; &#123;
        console.log(`[$&#123;address&#125;:$&#123;portWithRandomLog&#125;] $&#123;info&#125;`, event || &#39;&#39;);
    &#125;;
    const earlyDataHeader = request.headers.get(&#39;sec-websocket-protocol&#39;) || &#39;&#39;;

    const readableWebSocketStream = makeReadableWebSocketStream(webSocket, earlyDataHeader, log);

    /** @type &#123;&#123; value: import("@cloudflare/workers-types").Socket | null&#125;&#125;*/
    let remoteSocketWapper = &#123;
        value: null,
    &#125;;
    let isDns = false;

    // ws --&gt; remote
    readableWebSocketStream.pipeTo(new WritableStream(&#123;
        async write(chunk, controller) &#123;
            if (isDns) &#123;
                return await handleDNSQuery(chunk, webSocket, null, log);
            &#125;
            if (remoteSocketWapper.value) &#123;
                const writer = remoteSocketWapper.value.writable.getWriter()
                await writer.write(chunk);
                writer.releaseLock();
                return;
            &#125;

            const &#123;
                hasError,
                message,
                addressType,
                portRemote = 443,
                addressRemote = &#39;&#39;,
                rawDataIndex,
                vlessVersion = new Uint8Array([0, 0]),
                isUDP,
            &#125; = processVlessHeader(chunk, userID);
            address = addressRemote;
            portWithRandomLog = `$&#123;portRemote&#125;--$&#123;Math.random()&#125; $&#123;isUDP ? &#39;udp &#39; : &#39;tcp &#39;
                &#125; `;
            if (hasError) &#123;
                // controller.error(message);
                throw new Error(message); // cf seems has bug, controller.error will not end stream
                // webSocket.close(1000, message);
                return;
            &#125;
            // if UDP but port not DNS port, close it
            if (isUDP) &#123;
                if (portRemote === 53) &#123;
                    isDns = true;
                &#125; else &#123;
                    // controller.error(&#39;UDP proxy only enable for DNS which is port 53&#39;);
                    throw new Error(&#39;UDP proxy only enable for DNS which is port 53&#39;); // cf seems has bug, controller.error will not end stream
                    return;
                &#125;
            &#125;
            // [&quot;version&quot;, &quot;附加信息长度 N&quot;]
            const vlessResponseHeader = new Uint8Array([vlessVersion[0], 0]);
            const rawClientData = chunk.slice(rawDataIndex);

            if (isDns) &#123;
                return handleDNSQuery(rawClientData, webSocket, vlessResponseHeader, log);
            &#125;
            handleTCPOutBound(remoteSocketWapper, addressType, addressRemote, portRemote, rawClientData, webSocket, vlessResponseHeader, log);
        &#125;,
        close() &#123;
            log(`readableWebSocketStream is close`);
        &#125;,
        abort(reason) &#123;
            log(`readableWebSocketStream is abort`, JSON.stringify(reason));
        &#125;,
    &#125;)).catch((err) =&gt; &#123;
        log(&#39;readableWebSocketStream pipeTo error&#39;, err);
    &#125;);

    return new Response(null, &#123;
        status: 101,
        // @ts-ignore
        webSocket: client,
    &#125;);
&#125;

/**
 * Handles outbound TCP connections.
 *
 * @param &#123;any&#125; remoteSocket
 * @param &#123;number&#125; addressType The remote address type to connect to.
 * @param &#123;string&#125; addressRemote The remote address to connect to.
 * @param &#123;number&#125; portRemote The remote port to connect to.
 * @param &#123;Uint8Array&#125; rawClientData The raw client data to write.
 * @param &#123;import(&quot;@cloudflare/workers-types&quot;).WebSocket&#125; webSocket The WebSocket to pass the remote socket to.
 * @param &#123;Uint8Array&#125; vlessResponseHeader The VLESS response header.
 * @param &#123;function&#125; log The logging function.
 * @returns &#123;Promise&lt;void&gt;&#125; The remote socket.
 */
async function handleTCPOutBound(remoteSocket, addressType, addressRemote, portRemote, rawClientData, webSocket, vlessResponseHeader, log,) &#123;
    async function connectAndWrite(address, port, socks = false) &#123;
        /** @type &#123;import(&quot;@cloudflare/workers-types&quot;).Socket&#125; */
        const tcpSocket = socks ? await socks5Connect(addressType, address, port, log)
            : connect(&#123;
                hostname: address,
                port: port,
            &#125;);
        remoteSocket.value = tcpSocket;
        log(`connected to $&#123;address&#125;:$&#123;port&#125;`);
        const writer = tcpSocket.writable.getWriter();
        await writer.write(rawClientData); // first write, normal is tls client hello
        writer.releaseLock();
        return tcpSocket;
    &#125;

    // if the cf connect tcp socket have no incoming data, we retry to redirect ip
    async function retry() &#123;
        if (enableSocks) &#123;
            tcpSocket = await connectAndWrite(addressRemote, portRemote, true);
        &#125; else &#123;
            tcpSocket = await connectAndWrite(proxyIP || addressRemote, portRemote);
        &#125;
        // no matter retry success or not, close websocket
        tcpSocket.closed.catch(error =&gt; &#123;
            console.log(&#39;retry tcpSocket closed error&#39;, error);
        &#125;).finally(() =&gt; &#123;
            safeCloseWebSocket(webSocket);
        &#125;)
        remoteSocketToWS(tcpSocket, webSocket, vlessResponseHeader, null, log);
    &#125;

    let tcpSocket = await connectAndWrite(addressRemote, portRemote);

    // when remoteSocket is ready, pass to websocket
    // remote--&gt; ws
    remoteSocketToWS(tcpSocket, webSocket, vlessResponseHeader, retry, log);
&#125;

/**
 * 
 * @param &#123;import(&quot;@cloudflare/workers-types&quot;).WebSocket&#125; webSocketServer
 * @param &#123;string&#125; earlyDataHeader for ws 0rtt
 * @param &#123;(info: string)=&gt; void&#125; log for ws 0rtt
 */
function makeReadableWebSocketStream(webSocketServer, earlyDataHeader, log) &#123;
    let readableStreamCancel = false;
    const stream = new ReadableStream(&#123;
        start(controller) &#123;
            webSocketServer.addEventListener(&#39;message&#39;, (event) =&gt; &#123;
                if (readableStreamCancel) &#123;
                    return;
                &#125;
                const message = event.data;
                controller.enqueue(message);
            &#125;);

            // The event means that the client closed the client -&gt; server stream.
            // However, the server -&gt; client stream is still open until you call close() on the server side.
            // The WebSocket protocol says that a separate close message must be sent in each direction to fully close the socket.
            webSocketServer.addEventListener(&#39;close&#39;, () =&gt; &#123;
                // client send close, need close server
                // if stream is cancel, skip controller.close
                safeCloseWebSocket(webSocketServer);
                if (readableStreamCancel) &#123;
                    return;
                &#125;
                controller.close();
            &#125;
            );
            webSocketServer.addEventListener(&#39;error&#39;, (err) =&gt; &#123;
                log(&#39;webSocketServer has error&#39;);
                controller.error(err);
            &#125;
            );
            // for ws 0rtt
            const &#123; earlyData, error &#125; = base64ToArrayBuffer(earlyDataHeader);
            if (error) &#123;
                controller.error(error);
            &#125; else if (earlyData) &#123;
                controller.enqueue(earlyData);
            &#125;
        &#125;,

        pull(controller) &#123;
            // if ws can stop read if stream is full, we can implement backpressure
            // https://streams.spec.whatwg.org/#example-rs-push-backpressure
        &#125;,
        cancel(reason) &#123;
            // 1. pipe WritableStream has error, this cancel will called, so ws handle server close into here
            // 2. if readableStream is cancel, all controller.close/enqueue need skip,
            // 3. but from testing controller.error still work even if readableStream is cancel
            if (readableStreamCancel) &#123;
                return;
            &#125;
            log(`ReadableStream was canceled, due to $&#123;reason&#125;`)
            readableStreamCancel = true;
            safeCloseWebSocket(webSocketServer);
        &#125;
    &#125;);

    return stream;

&#125;

// https://xtls.github.io/development/protocols/vless.html
// https://github.com/zizifn/excalidraw-backup/blob/main/v2ray-protocol.excalidraw

/**
 * 
 * @param &#123; ArrayBuffer&#125; vlessBuffer 
 * @param &#123;string&#125; userID 
 * @returns 
 */
function processVlessHeader(vlessBuffer, userID) &#123;
    if (vlessBuffer.byteLength &lt; 24) &#123;
        return &#123;
            hasError: true,
            message: &#39;invalid data&#39;,
        &#125;;
    &#125;
    const version = new Uint8Array(vlessBuffer.slice(0, 1));
    let isValidUser = false;
    let isUDP = false;
    if (stringify(new Uint8Array(vlessBuffer.slice(1, 17))) === userID) &#123;
        isValidUser = true;
    &#125;
    if (!isValidUser) &#123;
        return &#123;
            hasError: true,
            message: &#39;invalid user&#39;,
        &#125;;
    &#125;

    const optLength = new Uint8Array(vlessBuffer.slice(17, 18))[0];
    //skip opt for now

    const command = new Uint8Array(
        vlessBuffer.slice(18 + optLength, 18 + optLength + 1)
    )[0];

    // 0x01 TCP
    // 0x02 UDP
    // 0x03 MUX
    if (command === 1) &#123;
    &#125; else if (command === 2) &#123;
        isUDP = true;
    &#125; else &#123;
        return &#123;
            hasError: true,
            message: `command $&#123;command&#125; is not support, command 01-tcp,02-udp,03-mux`,
        &#125;;
    &#125;
    const portIndex = 18 + optLength + 1;
    const portBuffer = vlessBuffer.slice(portIndex, portIndex + 2);
    // port is big-Endian in raw data etc 80 == 0x005d
    const portRemote = new DataView(portBuffer).getUint16(0);

    let addressIndex = portIndex + 2;
    const addressBuffer = new Uint8Array(
        vlessBuffer.slice(addressIndex, addressIndex + 1)
    );

    // 1--&gt; ipv4  addressLength =4
    // 2--&gt; domain name addressLength=addressBuffer[1]
    // 3--&gt; ipv6  addressLength =16
    const addressType = addressBuffer[0];
    let addressLength = 0;
    let addressValueIndex = addressIndex + 1;
    let addressValue = &#39;&#39;;
    switch (addressType) &#123;
        case 1:
            addressLength = 4;
            addressValue = new Uint8Array(
                vlessBuffer.slice(addressValueIndex, addressValueIndex + addressLength)
            ).join(&#39;.&#39;);
            break;
        case 2:
            addressLength = new Uint8Array(
                vlessBuffer.slice(addressValueIndex, addressValueIndex + 1)
            )[0];
            addressValueIndex += 1;
            addressValue = new TextDecoder().decode(
                vlessBuffer.slice(addressValueIndex, addressValueIndex + addressLength)
            );
            break;
        case 3:
            addressLength = 16;
            const dataView = new DataView(
                vlessBuffer.slice(addressValueIndex, addressValueIndex + addressLength)
            );
            // 2001:0db8:85a3:0000:0000:8a2e:0370:7334
            const ipv6 = [];
            for (let i = 0; i &lt; 8; i++) &#123;
                ipv6.push(dataView.getUint16(i * 2).toString(16));
            &#125;
            addressValue = ipv6.join(&#39;:&#39;);
            // seems no need add [] for ipv6
            break;
        default:
            return &#123;
                hasError: true,
                message: `invild  addressType is $&#123;addressType&#125;`,
            &#125;;
    &#125;
    if (!addressValue) &#123;
        return &#123;
            hasError: true,
            message: `addressValue is empty, addressType is $&#123;addressType&#125;`,
        &#125;;
    &#125;

    return &#123;
        hasError: false,
        addressRemote: addressValue,
        addressType,
        portRemote,
        rawDataIndex: addressValueIndex + addressLength,
        vlessVersion: version,
        isUDP,
    &#125;;
&#125;


/**
 * 
 * @param &#123;import(&quot;@cloudflare/workers-types&quot;).Socket&#125; remoteSocket 
 * @param &#123;import(&quot;@cloudflare/workers-types&quot;).WebSocket&#125; webSocket 
 * @param &#123;ArrayBuffer&#125; vlessResponseHeader 
 * @param &#123;(() =&gt; Promise&lt;void&gt;) | null&#125; retry
 * @param &#123;*&#125; log 
 */
async function remoteSocketToWS(remoteSocket, webSocket, vlessResponseHeader, retry, log) &#123;
    // remote--&gt; ws
    let remoteChunkCount = 0;
    let chunks = [];
    /** @type &#123;ArrayBuffer | null&#125; */
    let vlessHeader = vlessResponseHeader;
    let hasIncomingData = false; // check if remoteSocket has incoming data
    await remoteSocket.readable
        .pipeTo(
            new WritableStream(&#123;
                start() &#123;
                &#125;,
                /**
                 * 
                 * @param &#123;Uint8Array&#125; chunk 
                 * @param &#123;*&#125; controller 
                 */
                async write(chunk, controller) &#123;
                    hasIncomingData = true;
                    // remoteChunkCount++;
                    if (webSocket.readyState !== WS_READY_STATE_OPEN) &#123;
                        controller.error(
                            &#39;webSocket.readyState is not open, maybe close&#39;
                        );
                    &#125;
                    if (vlessHeader) &#123;
                        webSocket.send(await new Blob([vlessHeader, chunk]).arrayBuffer());
                        vlessHeader = null;
                    &#125; else &#123;
                        // seems no need rate limit this, CF seems fix this??..
                        // if (remoteChunkCount &gt; 20000) &#123;
                        // 	// cf one package is 4096 byte(4kb),  4096 * 20000 = 80M
                        // 	await delay(1);
                        // &#125;
                        webSocket.send(chunk);
                    &#125;
                &#125;,
                close() &#123;
                    log(`remoteConnection!.readable is close with hasIncomingData is $&#123;hasIncomingData&#125;`);
                    // safeCloseWebSocket(webSocket); // no need server close websocket frist for some case will casue HTTP ERR_CONTENT_LENGTH_MISMATCH issue, client will send close event anyway.
                &#125;,
                abort(reason) &#123;
                    console.error(`remoteConnection!.readable abort`, reason);
                &#125;,
            &#125;)
        )
        .catch((error) =&gt; &#123;
            console.error(
                `remoteSocketToWS has exception `,
                error.stack || error
            );
            safeCloseWebSocket(webSocket);
        &#125;);

    // seems is cf connect socket have error,
    // 1. Socket.closed will have error
    // 2. Socket.readable will be close without any data coming
    if (hasIncomingData === false &amp;&amp; retry) &#123;
        log(`retry`)
        retry();
    &#125;
&#125;

/**
 * 
 * @param &#123;string&#125; base64Str 
 * @returns 
 */
function base64ToArrayBuffer(base64Str) &#123;
    if (!base64Str) &#123;
        return &#123; error: null &#125;;
    &#125;
    try &#123;
        // go use modified Base64 for URL rfc4648 which js atob not support
        base64Str = base64Str.replace(/-/g, &#39;+&#39;).replace(/_/g, &#39;/&#39;);
        const decode = atob(base64Str);
        const arryBuffer = Uint8Array.from(decode, (c) =&gt; c.charCodeAt(0));
        return &#123; earlyData: arryBuffer.buffer, error: null &#125;;
    &#125; catch (error) &#123;
        return &#123; error &#125;;
    &#125;
&#125;

/**
 * This is not real UUID validation
 * @param &#123;string&#125; uuid 
 */
function isValidUUID(uuid) &#123;
    const uuidRegex = /^[0-9a-f]&#123;8&#125;-[0-9a-f]&#123;4&#125;-[4][0-9a-f]&#123;3&#125;-[89ab][0-9a-f]&#123;3&#125;-[0-9a-f]&#123;12&#125;$/i;
    return uuidRegex.test(uuid);
&#125;

const WS_READY_STATE_OPEN = 1;
const WS_READY_STATE_CLOSING = 2;
/**
 * Normally, WebSocket will not has exceptions when close.
 * @param &#123;import(&quot;@cloudflare/workers-types&quot;).WebSocket&#125; socket
 */
function safeCloseWebSocket(socket) &#123;
    try &#123;
        if (socket.readyState === WS_READY_STATE_OPEN || socket.readyState === WS_READY_STATE_CLOSING) &#123;
            socket.close();
        &#125;
    &#125; catch (error) &#123;
        console.error(&#39;safeCloseWebSocket error&#39;, error);
    &#125;
&#125;

const byteToHex = [];
for (let i = 0; i &lt; 256; ++i) &#123;
    byteToHex.push((i + 256).toString(16).slice(1));
&#125;
function unsafeStringify(arr, offset = 0) &#123;
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + &quot;-&quot; + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + &quot;-&quot; + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + &quot;-&quot; + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + &quot;-&quot; + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
&#125;
function stringify(arr, offset = 0) &#123;
    const uuid = unsafeStringify(arr, offset);
    if (!isValidUUID(uuid)) &#123;
        throw TypeError(&quot;Stringified UUID is invalid&quot;);
    &#125;
    return uuid;
&#125;

/**
 * 
 * @param &#123;ArrayBuffer&#125; udpChunk 
 * @param &#123;import(&quot;@cloudflare/workers-types&quot;).WebSocket&#125; webSocket 
 * @param &#123;ArrayBuffer&#125; vlessResponseHeader 
 * @param &#123;(string)=&gt; void&#125; log 
 */
async function handleDNSQuery(udpChunk, webSocket, vlessResponseHeader, log) &#123;
    // no matter which DNS server client send, we alwasy use hard code one.
    // beacsue someof DNS server is not support DNS over TCP
    try &#123;
        const dnsServer = &#39;8.8.4.4&#39;; // change to 1.1.1.1 after cf fix connect own ip bug
        const dnsPort = 53;
        /** @type &#123;ArrayBuffer | null&#125; */
        let vlessHeader = vlessResponseHeader;
        /** @type &#123;import(&quot;@cloudflare/workers-types&quot;).Socket&#125; */
        const tcpSocket = connect(&#123;
            hostname: dnsServer,
            port: dnsPort,
        &#125;);

        log(`connected to $&#123;dnsServer&#125;:$&#123;dnsPort&#125;`);
        const writer = tcpSocket.writable.getWriter();
        await writer.write(udpChunk);
        writer.releaseLock();
        await tcpSocket.readable.pipeTo(new WritableStream(&#123;
            async write(chunk) &#123;
                if (webSocket.readyState === WS_READY_STATE_OPEN) &#123;
                    if (vlessHeader) &#123;
                        webSocket.send(await new Blob([vlessHeader, chunk]).arrayBuffer());
                        vlessHeader = null;
                    &#125; else &#123;
                        webSocket.send(chunk);
                    &#125;
                &#125;
            &#125;,
            close() &#123;
                log(`dns server($&#123;dnsServer&#125;) tcp is close`);
            &#125;,
            abort(reason) &#123;
                console.error(`dns server($&#123;dnsServer&#125;) tcp is abort`, reason);
            &#125;,
        &#125;));
    &#125; catch (error) &#123;
        console.error(
            `handleDNSQuery have exception, error: $&#123;error.message&#125;`
        );
    &#125;
&#125;

/**
 * 
 * @param &#123;number&#125; addressType
 * @param &#123;string&#125; addressRemote
 * @param &#123;number&#125; portRemote
 * @param &#123;function&#125; log The logging function.
 */
async function socks5Connect(addressType, addressRemote, portRemote, log) &#123;
    const &#123; username, password, hostname, port &#125; = parsedSocks5Address;
    // Connect to the SOCKS server
    const socket = connect(&#123;
        hostname,
        port,
    &#125;);

    // Request head format (Worker -&gt; Socks Server):
    // +----+----------+----------+
    // |VER | NMETHODS | METHODS  |
    // +----+----------+----------+
    // | 1  |    1     | 1 to 255 |
    // +----+----------+----------+

    // https://en.wikipedia.org/wiki/SOCKS#SOCKS5
    // For METHODS:
    // 0x00 NO AUTHENTICATION REQUIRED
    // 0x02 USERNAME/PASSWORD https://datatracker.ietf.org/doc/html/rfc1929
    const socksGreeting = new Uint8Array([5, 2, 0, 2]);

    const writer = socket.writable.getWriter();

    await writer.write(socksGreeting);
    log(&#39;sent socks greeting&#39;);

    const reader = socket.readable.getReader();
    const encoder = new TextEncoder();
    let res = (await reader.read()).value;
    // Response format (Socks Server -&gt; Worker):
    // +----+--------+
    // |VER | METHOD |
    // +----+--------+
    // | 1  |   1    |
    // +----+--------+
    if (res[0] !== 0x05) &#123;
        log(`socks server version error: $&#123;res[0]&#125; expected: 5`);
        return;
    &#125;
    if (res[1] === 0xff) &#123;
        log(&quot;no acceptable methods&quot;);
        return;
    &#125;

    // if return 0x0502
    if (res[1] === 0x02) &#123;
        log(&quot;socks server needs auth&quot;);
        if (!username || !password) &#123;
            log(&quot;please provide username/password&quot;);
            return;
        &#125;
        // +----+------+----------+------+----------+
        // |VER | ULEN |  UNAME   | PLEN |  PASSWD  |
        // +----+------+----------+------+----------+
        // | 1  |  1   | 1 to 255 |  1   | 1 to 255 |
        // +----+------+----------+------+----------+
        const authRequest = new Uint8Array([
            1,
            username.length,
            ...encoder.encode(username),
            password.length,
            ...encoder.encode(password)
        ]);
        await writer.write(authRequest);
        res = (await reader.read()).value;
        // expected 0x0100
        if (res[0] !== 0x01 || res[1] !== 0x00) &#123;
            log(&quot;fail to auth socks server&quot;);
            return;
        &#125;
    &#125;

    // Request data format (Worker -&gt; Socks Server):
    // +----+-----+-------+------+----------+----------+
    // |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |
    // +----+-----+-------+------+----------+----------+
    // | 1  |  1  | X&#39;00&#39; |  1   | Variable |    2     |
    // +----+-----+-------+------+----------+----------+
    // ATYP: address type of following address
    // 0x01: IPv4 address
    // 0x03: Domain name
    // 0x04: IPv6 address
    // DST.ADDR: desired destination address
    // DST.PORT: desired destination port in network octet order

    // addressType
    // 1--&gt; ipv4  addressLength =4
    // 2--&gt; domain name
    // 3--&gt; ipv6  addressLength =16
    let DSTADDR;	// DSTADDR = ATYP + DST.ADDR
    switch (addressType) &#123;
        case 1:
            DSTADDR = new Uint8Array(
                [1, ...addressRemote.split(&#39;.&#39;).map(Number)]
            );
            break;
        case 2:
            DSTADDR = new Uint8Array(
                [3, addressRemote.length, ...encoder.encode(addressRemote)]
            );
            break;
        case 3:
            DSTADDR = new Uint8Array(
                [4, ...addressRemote.split(&#39;:&#39;).flatMap(x =&gt; [parseInt(x.slice(0, 2), 16), parseInt(x.slice(2), 16)])]
            );
            break;
        default:
            log(`invild  addressType is $&#123;addressType&#125;`);
            return;
    &#125;
    const socksRequest = new Uint8Array([5, 1, 0, ...DSTADDR, portRemote &gt;&gt; 8, portRemote &amp; 0xff]);
    await writer.write(socksRequest);
    log(&#39;sent socks request&#39;);

    res = (await reader.read()).value;
    // Response format (Socks Server -&gt; Worker):
    //  +----+-----+-------+------+----------+----------+
    // |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |
    // +----+-----+-------+------+----------+----------+
    // | 1  |  1  | X&#39;00&#39; |  1   | Variable |    2     |
    // +----+-----+-------+------+----------+----------+
    if (res[1] === 0x00) &#123;
        log(&quot;socks connection opened&quot;);
    &#125; else &#123;
        log(&quot;fail to open socks connection&quot;);
        return;
    &#125;
    writer.releaseLock();
    reader.releaseLock();
    return socket;
&#125;


/**
 * 
 * @param &#123;string&#125; address
 */
function socks5AddressParser(address) &#123;
    let [latter, former] = address.split(&quot;@&quot;).reverse();
    let username, password, hostname, port;
    if (former) &#123;
        const formers = former.split(&quot;:&quot;);
        if (formers.length !== 2) &#123;
            throw new Error(&#39;Invalid SOCKS address format&#39;);
        &#125;
        [username, password] = formers;
    &#125;
    const latters = latter.split(&quot;:&quot;);
    port = Number(latters.pop());
    if (isNaN(port)) &#123;
        throw new Error(&#39;Invalid SOCKS address format&#39;);
    &#125;
    hostname = latters.join(&quot;:&quot;);
    const regex = /^\[.*\]$/;
    if (hostname.includes(&quot;:&quot;) &amp;&amp; !regex.test(hostname)) &#123;
        throw new Error(&#39;Invalid SOCKS address format&#39;);
    &#125;
    return &#123;
        username,
        password,
        hostname,
        port,
    &#125;
&#125;

function revertFakeInfo(content, userID, hostName, isBase64) &#123;
    if (isBase64) content = atob(content);//Base64解码
    content = content.replace(new RegExp(fakeUserID, &#39;g&#39;), userID).replace(new RegExp(fakeHostName, &#39;g&#39;), hostName);
    if (isBase64) content = btoa(content);//Base64编码

    return content;
&#125;

async function MD5MD5(text) &#123;
    const encoder = new TextEncoder();
  
    const firstPass = await crypto.subtle.digest(&#39;MD5&#39;, encoder.encode(text));
    const firstPassArray = Array.from(new Uint8Array(firstPass));
    const firstHex = firstPassArray.map(b =&gt; b.toString(16).padStart(2, &#39;0&#39;)).join(&#39;&#39;);

    const secondPass = await crypto.subtle.digest(&#39;MD5&#39;, encoder.encode(firstHex.slice(7, 27)));
    const secondPassArray = Array.from(new Uint8Array(secondPass));
    const secondHex = secondPassArray.map(b =&gt; b.toString(16).padStart(2, &#39;0&#39;)).join(&#39;&#39;);
  
    return secondHex.toLowerCase();
&#125;

async function ADD(envadd) &#123;
    var addtext = envadd.replace(/[	|&quot;&#39;\r\n]+/g, &#39;,&#39;).replace(/,+/g, &#39;,&#39;);  // 将双引号、单引号和换行符替换为逗号
    //console.log(addtext);
    if (addtext.charAt(0) == &#39;,&#39;) addtext = addtext.slice(1);
    if (addtext.charAt(addtext.length -1) == &#39;,&#39;) addtext = addtext.slice(0, addtext.length - 1);
    const add = addtext.split(&#39;,&#39;);
    //console.log(add);
    return add ;
&#125;

const 啥啥啥_写的这是啥啊 = &#39;dmxlc3M=&#39;;
function 配置信息(UUID, 域名地址) &#123;
    const 协议类型 = atob(啥啥啥_写的这是啥啊);
    
    const 别名 = 域名地址;
    let 地址 = 域名地址;
    let 端口 = 443;

    const 用户ID = UUID;
    const 加密方式 = &#39;none&#39;;
    
    const 传输层协议 = &#39;ws&#39;;
    const 伪装域名 = 域名地址;
    const 路径 = &#39;/?ed=2560&#39;;
    
    let 传输层安全 = [&#39;tls&#39;,true];
    const SNI = 域名地址;
    const 指纹 = &#39;randomized&#39;;

    if (域名地址.includes(&#39;.workers.dev&#39;))&#123;
        地址 = &#39;www.wto.org&#39;;
        端口 = 80 ;
        传输层安全 = [&#39;&#39;,false];
    &#125;

    const v2ray = `$&#123;协议类型&#125;://$&#123;用户ID&#125;@$&#123;地址&#125;:$&#123;端口&#125;?encryption=$&#123;加密方式&#125;&amp;security=$&#123;传输层安全[0]&#125;&amp;sni=$&#123;SNI&#125;&amp;fp=$&#123;指纹&#125;&amp;type=$&#123;传输层协议&#125;&amp;host=$&#123;伪装域名&#125;&amp;path=$&#123;encodeURIComponent(路径)&#125;#$&#123;encodeURIComponent(别名)&#125;`;
    const clash = `- type: $&#123;协议类型&#125;
  name: $&#123;别名&#125;
  server: $&#123;地址&#125;
  port: $&#123;端口&#125;
  uuid: $&#123;用户ID&#125;
  network: $&#123;传输层协议&#125;
  tls: $&#123;传输层安全[1]&#125;
  udp: false
  sni: $&#123;SNI&#125;
  client-fingerprint: $&#123;指纹&#125;
  ws-opts:
    path: &quot;$&#123;路径&#125;&quot;
    headers:
      host: $&#123;伪装域名&#125;`;
    return [v2ray,clash];
&#125;

let subParams = [&#39;sub&#39;,&#39;base64&#39;,&#39;b64&#39;,&#39;clash&#39;,&#39;singbox&#39;,&#39;sb&#39;];

/**
 * @param &#123;string&#125; userID
 * @param &#123;string | null&#125; hostName
 * @param &#123;string&#125; sub
 * @param &#123;string&#125; UA
 * @returns &#123;Promise&lt;string&gt;&#125;
 */
async function getVLESSConfig(userID, hostName, sub, UA, RproxyIP, _url) &#123;
    const userAgent = UA.toLowerCase();
    const Config = 配置信息(userID , hostName);
    const v2ray = Config[0];
    const clash = Config[1];
    // 如果sub为空，则显示原始内容
    if ( userAgent.includes(&#39;mozilla&#39;) &amp;&amp; !subParams.some(_searchParams =&gt; _url.searchParams.has(_searchParams))) &#123;
        let 订阅器 = `您的订阅内容由 $&#123;sub&#125; 提供维护支持, 自动获取ProxyIP: $&#123;RproxyIP&#125;`;
        if (!sub || sub == &#39;&#39;) &#123;
            if (!proxyIP || proxyIP ==&#39;&#39;) &#123;
                订阅器 = &#39;您的订阅内容由 内置 addresses/ADD 参数提供, 当前使用的ProxyIP为空, 推荐您设置 proxyIP/PROXYIP ！！！&#39;;
            &#125; else &#123;
                订阅器 = `您的订阅内容由 内置 addresses/ADD 参数提供, 当前使用的ProxyIP： $&#123;proxyIPs.join(&#39;,&#39;)&#125;`;
            &#125;
        &#125; else if (RproxyIP != &#39;true&#39;)&#123;
            订阅器 += `, 当前使用的ProxyIP： $&#123;proxyIPs.join(&#39;,&#39;)&#125;`;
        &#125;
        return `
################################################################
Subscribe / sub 订阅地址, 支持 Base64、clash-meta、sing-box 订阅格式, $&#123;订阅器&#125;
---------------------------------------------------------------
快速自适应订阅地址:
https://$&#123;hostName&#125;/$&#123;userID&#125;

Base64订阅地址:
https://$&#123;hostName&#125;/$&#123;userID&#125;?sub
https://$&#123;hostName&#125;/$&#123;userID&#125;?b64
https://$&#123;hostName&#125;/$&#123;userID&#125;?base64

clash订阅地址:
https://$&#123;hostName&#125;/$&#123;userID&#125;?clash

singbox订阅地址:
https://$&#123;hostName&#125;/$&#123;userID&#125;?sb
https://$&#123;hostName&#125;/$&#123;userID&#125;?singbox
---------------------------------------------------------------
################################################################
v2ray
---------------------------------------------------------------
$&#123;v2ray&#125;
---------------------------------------------------------------
################################################################
clash-meta
---------------------------------------------------------------
$&#123;clash&#125;
---------------------------------------------------------------

`;
    &#125; else &#123;
        if (typeof fetch != &#39;function&#39;) &#123;
            return &#39;Error: fetch is not available in this environment.&#39;;
        &#125;

        let newAddressesapi ;
        let newAddressescsv ;
        let newAddressesnotlsapi;
        let newAddressesnotlscsv;

        // 如果是使用默认域名，则改成一个workers的域名，订阅器会加上代理
        if (hostName.includes(&quot;.workers.dev&quot;))&#123;
            fakeHostName = `$&#123;fakeHostName&#125;.workers.dev`;
            newAddressesnotlsapi = await getAddressesapi(addressesnotlsapi);
            newAddressesnotlscsv = await getAddressescsv(&#39;FALSE&#39;);
        &#125; else if (hostName.includes(&quot;.pages.dev&quot;))&#123;
            fakeHostName = `$&#123;fakeHostName&#125;.pages.dev`;
        &#125; else if (hostName.includes(&quot;worker&quot;) || hostName.includes(&quot;notls&quot;) || noTLS == &#39;true&#39;)&#123;
            fakeHostName = `notls.$&#123;fakeHostName&#125;.net`;
            newAddressesnotlsapi = await getAddressesapi(addressesnotlsapi);
            newAddressesnotlscsv = await getAddressescsv(&#39;FALSE&#39;);
        &#125; else &#123;
            fakeHostName = `$&#123;fakeHostName&#125;.xyz`
        &#125;

        let url = `https://$&#123;sub&#125;/sub?host=$&#123;fakeHostName&#125;&amp;uuid=$&#123;fakeUserID&#125;&amp;edgetunnel=cmliu&amp;proxyip=$&#123;RproxyIP&#125;`;
        let isBase64 = true;

        if (!sub || sub == &quot;&quot;)&#123;
            if(hostName.includes(&#39;workers.dev&#39;) || hostName.includes(&#39;pages.dev&#39;)) &#123;
                if (proxyhostsURL &amp;&amp; (!proxyhosts || proxyhosts.length == 0)) &#123;
                    try &#123;
                        const response = await fetch(proxyhostsURL); 
                    
                        if (!response.ok) &#123;
                            console.error(&#39;获取地址时出错:&#39;, response.status, response.statusText);
                            return; // 如果有错误，直接返回
                        &#125;
                    
                        const text = await response.text();
                        const lines = text.split(&#39;\n&#39;);
                        // 过滤掉空行或只包含空白字符的行
                        const nonEmptyLines = lines.filter(line =&gt; line.trim() !== &#39;&#39;);
                    
                        proxyhosts = proxyhosts.concat(nonEmptyLines);
                    &#125; catch (error) &#123;
                        console.error(&#39;获取地址时出错:&#39;, error);
                    &#125;
                &#125;
                // 使用Set对象去重
                proxyhosts = [...new Set(proxyhosts)];
            &#125;
    
            newAddressesapi = await getAddressesapi(addressesapi);
            newAddressescsv = await getAddressescsv(&#39;TRUE&#39;);
            url = `https://$&#123;hostName&#125;/$&#123;fakeUserID&#125;`;
        &#125; 

        if (!userAgent.includes((&#39;CF-Workers-SUB&#39;).toLowerCase()))&#123;
            if ((userAgent.includes(&#39;clash&#39;) &amp;&amp; !userAgent.includes(&#39;nekobox&#39;)) || ( _url.searchParams.has(&#39;clash&#39;) &amp;&amp; !userAgent.includes(&#39;subconverter&#39;))) &#123;
                url = `https://$&#123;subconverter&#125;/sub?target=clash&amp;url=$&#123;encodeURIComponent(url)&#125;&amp;insert=false&amp;config=$&#123;encodeURIComponent(subconfig)&#125;&amp;emoji=true&amp;list=false&amp;tfo=false&amp;scv=true&amp;fdn=false&amp;sort=false&amp;new_name=true`;
                isBase64 = false;
            &#125; else if (userAgent.includes(&#39;sing-box&#39;) || userAgent.includes(&#39;singbox&#39;) || (( _url.searchParams.has(&#39;singbox&#39;) || _url.searchParams.has(&#39;sb&#39;)) &amp;&amp; !userAgent.includes(&#39;subconverter&#39;))) &#123;
                url = `https://$&#123;subconverter&#125;/sub?target=singbox&amp;url=$&#123;encodeURIComponent(url)&#125;&amp;insert=false&amp;config=$&#123;encodeURIComponent(subconfig)&#125;&amp;emoji=true&amp;list=false&amp;tfo=false&amp;scv=true&amp;fdn=false&amp;sort=false&amp;new_name=true`;
                isBase64 = false;
            &#125;
        &#125;
        
        try &#123;
            let content;
            if ((!sub || sub == &quot;&quot;) &amp;&amp; isBase64 == true) &#123;
                content = await subAddresses(fakeHostName,fakeUserID,noTLS,newAddressesapi,newAddressescsv,newAddressesnotlsapi,newAddressesnotlscsv);
            &#125; else &#123;
                const response = await fetch(url ,&#123;
                    headers: &#123;
                        &#39;User-Agent&#39;: `$&#123;UA&#125; CF-Workers-edgetunnel/cmliu`
                    &#125;&#125;);
                content = await response.text();
            &#125;
            if (!_url.pathname.includes(`/$&#123;fakeUserID&#125;`)) content = revertFakeInfo(content, userID, hostName, isBase64);
            return content;
        &#125; catch (error) &#123;
            console.error(&#39;Error fetching content:&#39;, error);
            return `Error fetching content: $&#123;error.message&#125;`;
        &#125;

    &#125;
&#125;

async function getAccountId(email, key) &#123;
    try &#123;
        const url = &#39;https://api.cloudflare.com/client/v4/accounts&#39;;
        const headers = new Headers(&#123;
            &#39;X-AUTH-EMAIL&#39;: email,
            &#39;X-AUTH-KEY&#39;: key
        &#125;);
        const response = await fetch(url, &#123; headers &#125;);
        const data = await response.json();
        return data.result[0].id; // 假设我们需要第一个账号ID
    &#125; catch (error) &#123;
        return false ;
    &#125;
&#125;

async function getSum(accountId, accountIndex, email, key, startDate, endDate) &#123;
    try &#123;
        const startDateISO = new Date(startDate).toISOString();
        const endDateISO = new Date(endDate).toISOString();
    
        const query = JSON.stringify(&#123;
            query: `query getBillingMetrics($accountId: String!, $filter: AccountWorkersInvocationsAdaptiveFilter_InputObject) &#123;
                viewer &#123;
                    accounts(filter: &#123;accountTag: $accountId&#125;) &#123;
                        pagesFunctionsInvocationsAdaptiveGroups(limit: 1000, filter: $filter) &#123;
                            sum &#123;
                                requests
                            &#125;
                        &#125;
                        workersInvocationsAdaptive(limit: 10000, filter: $filter) &#123;
                            sum &#123;
                                requests
                            &#125;
                        &#125;
                    &#125;
                &#125;
            &#125;`,
            variables: &#123;
                accountId,
                filter: &#123; datetime_geq: startDateISO, datetime_leq: endDateISO &#125;
            &#125;,
        &#125;);
    
        const headers = new Headers(&#123;
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;X-AUTH-EMAIL&#39;: email,
            &#39;X-AUTH-KEY&#39;: key,
        &#125;);
    
        const response = await fetch(`https://api.cloudflare.com/client/v4/graphql`, &#123;
            method: &#39;POST&#39;,
            headers: headers,
            body: query
        &#125;);
    
        if (!response.ok) &#123;
            throw new Error(`HTTP error! status: $&#123;response.status&#125;`);
        &#125;
    
        const res = await response.json();
    
        const pagesFunctionsInvocationsAdaptiveGroups = res?.data?.viewer?.accounts?.[accountIndex]?.pagesFunctionsInvocationsAdaptiveGroups;
        const workersInvocationsAdaptive = res?.data?.viewer?.accounts?.[accountIndex]?.workersInvocationsAdaptive;
    
        if (!pagesFunctionsInvocationsAdaptiveGroups &amp;&amp; !workersInvocationsAdaptive) &#123;
            throw new Error(&#39;找不到数据&#39;);
        &#125;
    
        const pagesSum = pagesFunctionsInvocationsAdaptiveGroups.reduce((a, b) =&gt; a + b?.sum.requests, 0);
        const workersSum = workersInvocationsAdaptive.reduce((a, b) =&gt; a + b?.sum.requests, 0);
    
        //console.log(`范围: $&#123;startDateISO&#125; ~ $&#123;endDateISO&#125;\n默认取第 $&#123;accountIndex&#125; 项`);
    
        return [pagesSum, workersSum ];
    &#125; catch (error) &#123;
        return [ 0,0 ];
    &#125;
&#125;

async function getAddressesapi(api) &#123;
    if (!api || api.length === 0) &#123;
        return [];
    &#125;

    let newapi = &quot;&quot;;

    // 创建一个AbortController对象，用于控制fetch请求的取消
    const controller = new AbortController();

    const timeout = setTimeout(() =&gt; &#123;
        controller.abort(); // 取消所有请求
    &#125;, 2000); // 2秒后触发

    try &#123;
        // 使用Promise.allSettled等待所有API请求完成，无论成功或失败
        // 对api数组进行遍历，对每个API地址发起fetch请求
        const responses = await Promise.allSettled(api.map(apiUrl =&gt; fetch(apiUrl, &#123;
            method: &#39;get&#39;, 
            headers: &#123;
                &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;&#39;,
                &#39;User-Agent&#39;: &#39;CF-Workers-edgetunnel/cmliu&#39;
            &#125;,
            signal: controller.signal // 将AbortController的信号量添加到fetch请求中，以便于需要时可以取消请求
        &#125;).then(response =&gt; response.ok ? response.text() : Promise.reject())));

        // 遍历所有响应
        for (const response of responses) &#123;
            // 检查响应状态是否为&#39;fulfilled&#39;，即请求成功完成
            if (response.status === &#39;fulfilled&#39;) &#123;
                // 获取响应的内容
                const content = await response.value;
                newapi += content + &#39;\n&#39;;
            &#125;
        &#125;
    &#125; catch (error) &#123;
        console.error(error);
    &#125; finally &#123;
        // 无论成功或失败，最后都清除设置的超时定时器
        clearTimeout(timeout);
    &#125;

    const newAddressesapi = await ADD(newapi);

    // 返回处理后的结果
    return newAddressesapi;
&#125;

async function getAddressescsv(tls) &#123;
    if (!addressescsv || addressescsv.length === 0) &#123;
        return [];
    &#125;
    
    let newAddressescsv = [];
    
    for (const csvUrl of addressescsv) &#123;
        try &#123;
            const response = await fetch(csvUrl);
        
            if (!response.ok) &#123;
                console.error(&#39;获取CSV地址时出错:&#39;, response.status, response.statusText);
                continue;
            &#125;
        
            const text = await response.text();// 使用正确的字符编码解析文本内容
            let lines;
            if (text.includes(&#39;\r\n&#39;))&#123;
                lines = text.split(&#39;\r\n&#39;);
            &#125; else &#123;
                lines = text.split(&#39;\n&#39;);
            &#125;
        
            // 检查CSV头部是否包含必需字段
            const header = lines[0].split(&#39;,&#39;);
            const tlsIndex = header.indexOf(&#39;TLS&#39;);
            const speedIndex = header.length - 1; // 最后一个字段
        
            const ipAddressIndex = 0;// IP地址在 CSV 头部的位置
            const portIndex = 1;// 端口在 CSV 头部的位置
            const dataCenterIndex = tlsIndex + 1; // 数据中心是 TLS 的后一个字段
        
            if (tlsIndex === -1) &#123;
                console.error(&#39;CSV文件缺少必需的字段&#39;);
                continue;
            &#125;
        
            // 从第二行开始遍历CSV行
            for (let i = 1; i &lt; lines.length; i++) &#123;
                const columns = lines[i].split(&#39;,&#39;);
        
                // 检查TLS是否为&quot;TRUE&quot;且速度大于DLS
                if (columns[tlsIndex].toUpperCase() === tls &amp;&amp; parseFloat(columns[speedIndex]) &gt; DLS) &#123;
                    const ipAddress = columns[ipAddressIndex];
                    const port = columns[portIndex];
                    const dataCenter = columns[dataCenterIndex];
            
                    const formattedAddress = `$&#123;ipAddress&#125;:$&#123;port&#125;#$&#123;dataCenter&#125;`;
                    newAddressescsv.push(formattedAddress);
                &#125;
            &#125;
        &#125; catch (error) &#123;
            console.error(&#39;获取CSV地址时出错:&#39;, error);
            continue;
        &#125;
    &#125;
    
    return newAddressescsv;
&#125;

function subAddresses(host,UUID,noTLS,newAddressesapi,newAddressescsv,newAddressesnotlsapi,newAddressesnotlscsv) &#123;
    const regex = /^(\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;|\[.*\]):?(\d+)?#?(.*)?$/;
    addresses = addresses.concat(newAddressesapi);
    addresses = addresses.concat(newAddressescsv);
    let notlsresponseBody ;
    if (noTLS == &#39;true&#39;)&#123;
        addressesnotls = addressesnotls.concat(newAddressesnotlsapi);
        addressesnotls = addressesnotls.concat(newAddressesnotlscsv);
        const uniqueAddressesnotls = [...new Set(addressesnotls)];

        notlsresponseBody = uniqueAddressesnotls.map(address =&gt; &#123;
            let port = &quot;80&quot;;
            let addressid = address;
        
            const match = addressid.match(regex);
            if (!match) &#123;
                if (address.includes(&#39;:&#39;) &amp;&amp; address.includes(&#39;#&#39;)) &#123;
                    const parts = address.split(&#39;:&#39;);
                    address = parts[0];
                    const subParts = parts[1].split(&#39;#&#39;);
                    port = subParts[0];
                    addressid = subParts[1];
                &#125; else if (address.includes(&#39;:&#39;)) &#123;
                    const parts = address.split(&#39;:&#39;);
                    address = parts[0];
                    port = parts[1];
                &#125; else if (address.includes(&#39;#&#39;)) &#123;
                    const parts = address.split(&#39;#&#39;);
                    address = parts[0];
                    addressid = parts[1];
                &#125;
            
                if (addressid.includes(&#39;:&#39;)) &#123;
                    addressid = addressid.split(&#39;:&#39;)[0];
                &#125;
            &#125; else &#123;
                address = match[1];
                port = match[2] || port;
                addressid = match[3] || address;
            &#125;

            let 伪装域名 = host ;
            let 最终路径 = &#39;/?ed=2560&#39; ;
            let 节点备注 = &#39;&#39;;
            
            if(proxyhosts.length &gt; 0 &amp;&amp; (伪装域名.includes(&#39;.workers.dev&#39;) || 伪装域名.includes(&#39;pages.dev&#39;))) &#123;
                最终路径 = `/$&#123;伪装域名&#125;$&#123;最终路径&#125;`;
                伪装域名 = proxyhosts[Math.floor(Math.random() * proxyhosts.length)];
                节点备注 = ` 已启用临时域名中转服务，请尽快绑定自定义域！`;
            &#125;

            const vlessLink = `vless://$&#123;UUID&#125;@$&#123;address&#125;:$&#123;port&#125;?encryption=none&amp;security=&amp;type=ws&amp;host=$&#123;伪装域名&#125;&amp;path=$&#123;encodeURIComponent(最终路径)&#125;#$&#123;encodeURIComponent(addressid + 节点备注)&#125;`;
    
            return vlessLink;

        &#125;).join(&#39;\n&#39;);

    &#125;

    // 使用Set对象去重
    const uniqueAddresses = [...new Set(addresses)];

    const responseBody = uniqueAddresses.map(address =&gt; &#123;
        let port = &quot;443&quot;;
        let addressid = address;

        const match = addressid.match(regex);
        if (!match) &#123;
            if (address.includes(&#39;:&#39;) &amp;&amp; address.includes(&#39;#&#39;)) &#123;
                const parts = address.split(&#39;:&#39;);
                address = parts[0];
                const subParts = parts[1].split(&#39;#&#39;);
                port = subParts[0];
                addressid = subParts[1];
            &#125; else if (address.includes(&#39;:&#39;)) &#123;
                const parts = address.split(&#39;:&#39;);
                address = parts[0];
                port = parts[1];
            &#125; else if (address.includes(&#39;#&#39;)) &#123;
                const parts = address.split(&#39;#&#39;);
                address = parts[0];
                addressid = parts[1];
            &#125;
        
            if (addressid.includes(&#39;:&#39;)) &#123;
                addressid = addressid.split(&#39;:&#39;)[0];
            &#125;
        &#125; else &#123;
            address = match[1];
            port = match[2] || port;
            addressid = match[3] || address;
        &#125;
        
        let 伪装域名 = host ;
        let 最终路径 = &#39;/?ed=2560&#39; ;
        let 节点备注 = &#39;&#39;;
        
        if(proxyhosts.length &gt; 0 &amp;&amp; (伪装域名.includes(&#39;.workers.dev&#39;) || 伪装域名.includes(&#39;pages.dev&#39;))) &#123;
            最终路径 = `/$&#123;伪装域名&#125;$&#123;最终路径&#125;`;
            伪装域名 = proxyhosts[Math.floor(Math.random() * proxyhosts.length)];
            节点备注 = ` 已启用临时域名中转服务，请尽快绑定自定义域！`;
        &#125;
        
        const 协议类型 = atob(啥啥啥_写的这是啥啊);
        const vlessLink = `$&#123;协议类型&#125;://$&#123;UUID&#125;@$&#123;address&#125;:$&#123;port&#125;?encryption=none&amp;security=tls&amp;sni=$&#123;伪装域名&#125;&amp;fp=random&amp;type=ws&amp;host=$&#123;伪装域名&#125;&amp;path=$&#123;encodeURIComponent(最终路径)&#125;#$&#123;encodeURIComponent(addressid + 节点备注)&#125;`;
            
        return vlessLink;
    &#125;).join(&#39;\n&#39;);

    let base64Response = responseBody; // 重新进行 Base64 编码
    if(noTLS == &#39;true&#39;) base64Response += `\nnotlsresponseBody`;
    return btoa(base64Response);
&#125;

async function sendMessage(type, ip, add_data = &quot;&quot;) &#123;
    if ( BotToken !== &#39;&#39; &amp;&amp; ChatID !== &#39;&#39;)&#123;
        let msg = &quot;&quot;;
        const response = await fetch(`http://ip-api.com/json/$&#123;ip&#125;?lang=zh-CN`);
        if (response.status == 200) &#123;
            const ipInfo = await response.json();
            msg = `$&#123;type&#125;\nIP: $&#123;ip&#125;\n国家: $&#123;ipInfo.country&#125;\n&lt;tg-spoiler&gt;城市: $&#123;ipInfo.city&#125;\n组织: $&#123;ipInfo.org&#125;\nASN: $&#123;ipInfo.as&#125;\n$&#123;add_data&#125;`;
        &#125; else &#123;
            msg = `$&#123;type&#125;\nIP: $&#123;ip&#125;\n&lt;tg-spoiler&gt;$&#123;add_data&#125;`;
        &#125;
    
        let url = &quot;https://api.telegram.org/bot&quot;+ BotToken +&quot;/sendMessage?chat_id=&quot; + ChatID + &quot;&amp;parse_mode=HTML&amp;text=&quot; + encodeURIComponent(msg);
        return fetch(url, &#123;
            method: &#39;get&#39;,
            headers: &#123;
                &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;&#39;,
                &#39;Accept-Encoding&#39;: &#39;gzip, deflate, br&#39;,
                &#39;User-Agent&#39;: &#39;Mozilla/5.0 Chrome/90.0.4430.72&#39;
            &#125;
        &#125;);
    &#125;
&#125;
</code></pre>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>


    




    



<!-- baidu url auto push script -->
<script type="text/javascript">
    !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=window.location.href,o=document.referrer;if(!e.test(r)){var n="//api.share.baidu.com/s.gif";o?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var t=new Image;t.src=n}}(window);
</script>     
</section>
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; ysun 
        </div>
    </div>
</footer>
         
    
        
<script src="/libs/lightgallery/js/lightgallery.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-pager.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-zoom.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-hash.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-share.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-video.min.js"></script>

    
    
        
<script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>

    
    
        <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true,
            TeX: {
                equationNumbers: {
                  autoNumber: 'AMS'
                }
            }
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    



<!-- Custom Scripts -->

<script src="/js/main.js"></script>


<!-- PrismJS Support -->
<script>
  document.querySelectorAll("pre code").forEach((block) => {
    // Add line-numbers class to pre
    block.parentElement.classList.add("line-numbers");

    // Ensure language class has 'language-' prefix
    block.classList.forEach((cls) => {
      if (!cls.startsWith("language-") && cls !== "hljs") {
        block.classList.add("language-" + cls);
      }
    });
  });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
<script src="/js/pdf-tools.js"></script>

<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script>
<script src="/js/code-tools.js"></script>
<link rel="stylesheet" href="/css/code-tools.css" />

    </div>

        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body>
</html>